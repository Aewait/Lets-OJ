# 题目来源
> https://www.nowcoder.com/questionTerminal/480d2b484e1f43af8ea8434770811b4a

老猴子辛苦了一辈子，给那群小猴子们留下了一笔巨大的财富——一大堆桃子。老猴子决定把这些桃子分给小猴子。
  第一个猴子来了，它把桃子分成五堆，五堆一样多，但还多出一个。它把剩下的一个留给老猴子，自己拿走其中的一堆。
  第二个猴子来了，它把桃子分成五堆，五堆一样多，但又多出一个。它把多出的一个留给老猴子，自己拿走其中的一堆。
  后来的小猴子都如此照办。最后剩下的桃子全部留给老猴子。
  这里有n只小猴子，请你写个程序计算一下在开始时至少有多少个桃子，以及最后老猴子最少能得到几个桃子。                          

# 题解

以下是别人的题解

## 思路1

```
纯数学题，思路与前面人的思路不太一样，不用借桃子，直接根据题意来进行求解
设最少需要桃子X个：
第一次经过题目的处理剩余桃子数目为：4/5 (X-1)=(4/5)*X-(4/5)；

第二次剩余桃子个数为：4/5(4/5(X-1)-1)=((4/5)^2)*X-(4/5)^2-(4/5)；

第三次剩余桃子个数为：4/5(4/5(4/5(X-1)-1)-1)=((4/5)^3)*X-(4/5)^3-(4/5)^2-(4/5)；


依次类推，经过n只猴子的类似处理，剩余桃子数为：

4/5(4/5(4/5(....(4/5(X-1)...)-1)-1)-1)=((4/5)^n)*X)-(4/5)^n-(4/5)^(n-1)-...-(4/5)
=((4/5)^n)*X)-4[1-(4/5)^n]
=(X+4)*(4/5)^n-4

```

同前人的推导一致，最终，只需要满足x+4的值为5^n次方则可以保证最后能得到一个整数，满足题目的要求

## 思路2

链接：https://www.nowcoder.com/questionTerminal/480d2b484e1f43af8ea8434770811b4a
来源：牛客网



```
　从题目中来看，小猴子每次将桃子均分为 5 堆时都会多出来 1 个，所以为了方便计算，我们在最开始时就借给猴子们 4 个桃子，这样的话，每次都可以刚好均分为 5 堆。

　　假设在开始时就有 X 个桃子，借给猴子们 4 个后，此时就一共有 X+4 个桃子。
　　当第一只小猴子来时，它将 X+4 个桃子均分为 5 堆后，拿走 (X+4)*(1/5) 个，剩余 (X+4)*(4/5) 个桃子。在这里，有人可能会有疑问：给老猴子的那个桃子去哪里呢？其实，小猴子拿的那一部分就包括了这一个桃子，并且小猴子也没有多得桃子，它实际上得到的桃子数为 (X+4)*(1/5) - 1 = (X-1)*(1/5) ，这和在不借给它们 4 个桃子的情况下得到的数量是一样的，不过此时剩余的桃子数相较于之前多了 (X+4)*(4/5) - (X-1)*(4/5) = 4 个，但这样就恰巧保证了下一只小猴子分桃时，也能刚好均分为 5 堆。由此可见，所有的小猴子都不会多得桃子，老猴子也不会少得桃子，并且每次小猴子都能刚好将桃子均分为 5 堆，而借给的那 4 个桃子每次都在剩余的那部分里，最后去除即可。
　　当第二只小猴子来时，它将 (X+4)*(4/5) 个桃子均分为 5 堆后，拿走 (X+4)*(4/5)*(1/5) 个，剩余 (X+4)*(4/5)^2 个桃子。
　　当第三只小猴子来时，它将 (X+4)*(4/5)^2 个桃子均分为 5 堆后，拿走 (X+4)*(4/5)^2*(1/5) 个，剩余 (X+4)*(4/5)^3 个桃子。
　　.....
　　依次类推，当第 n 只小猴子（最后一只小猴子）来时，它将 (X+4)*(4/5)^(n-1) 个桃子均分为 5 堆后，拿走 (X+4)*(4/5)^(n-1)*(1/5) 个，剩余 (X+4)*(4/5)^n 个桃子。

　　为了满足题目最后的要求，也就是要保证最后剩余的桃子数最少且为整数，那么当 X+4 = 5^n 时，刚好满足要求，此时可得出：
（1）开始时的总桃子数：X = 5^n - 4
（2）老猴子最后能得到的桃子数：n + (X+4)*(4/5)^n - 4 = n + 4^n - 4
　　因为老猴子能得到的桃子主要有两个来源：一是每个小猴子都要给一个，有 n 只小猴子，就可以得到 n 个；二是最后剩余的桃子都归老猴子所有，从上面最后一次的结果来看，一共剩余了 (X+4)*(4/5)^n 个桃子，但是这里面包括我们最早借给它们的 4 个，实际上剩余的桃子数为 (X+4)*(4/5)^n - 4 ，所以最后总共能得到的桃子数就是 n + (X+4)*(4/5)^n - 4 。
```

# 代码

~~~cpp
// write your code here cpp
//#include<iostream>
#include <bits/stdc++.h>
#include<math.h>
using namespace std;

int main()
{
    int n;
    while(cin>>n && n!=0)
    {
        //防止cout科学计数法
        cout << fixed << setprecision(0) << pow(5,n)-4 << " " << pow(4,n)+n-4 << endl;
    }
    return 0;
}
~~~

如果不用fix，cout会输出科学计数法，使用这种方式可以避免cout默认输出科学计数法

当然还有一个办法就是把内容保存到一个变量里面之后，在输出

或者使用`printf`

> 参考https://dgxue.blog.csdn.net/article/details/123927874?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123927874-blog-100049951.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123927874-blog-100049951.pc_relevant_recovery_v2&utm_relevant_index=1