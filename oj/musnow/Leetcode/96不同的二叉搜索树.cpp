class Solution {
public:
    int numTrees(int n) {
        vector<int> v(n + 1, 0);
        v[0] = 1; // 没有节点的数也算一颗树
        // i代表当前树中有几个节点
        for (int i = 1; i <= n; i++) {
            // j是单个循环中的处理，我们需要从0 * i-1 一直走到 i-1 * 0
            for (int j = 1; j <= i; j++) {
                v[i] += v[j - 1] * v[i - j];
            }
        }
        return v[n];
    }
};
// 下面这个题解比较好理解一些。首先要知道这个题目的答案是可以被缩小范围的
// https://leetcode.cn/problems/unique-binary-search-trees/solutions/331743/er-cha-sou-suo-shu-fu-xi-li-zi-jie-shi-si-lu-by-xi/

// 需要得出某个值为根节点的时候，这颗树的形态个数是(左边节点数量时的形态个数)*(右边节点数量时的形态个数)
// 以[1,2,3]为例
// 当1为根节点的时候，左子树为空，右子树2个元素，那么当前树的形态数量就是 f(0) * f(2)，即只由右边的两个元素的树的形态数量决定
// 当2为根节点的时候，左右子树都有1个元素，此时树的形态数量是 f(1) * f(1)，即由两个元素只有1的树的形态数量组合决定
// 当3为根节点的时候，右子树为空，左子树2个元素，这和1为根节点的情况类似，即当前树只由左边两个元素的树的形态数量决定，f(2) * f(0)
// 这下就可以得到公式 f(3) = f(0) * f(2) + f(1) * f(1) + f(2) * f(0)
// 进一步得到i的公式 f(i) = f(0) * f(i-1) + f(1) * f(i-2) + ... + f(i-1) * f(0)
// 我们要做的就是把这个公式转换成一个循环中的累加，即上面代码中的for循环。
// 注意vector中的值应该都初始化为0，不然累加的时候会出问题。
