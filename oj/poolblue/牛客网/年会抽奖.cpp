#include <iostream>
//错排问题
//用A、B、C……表示写着ｎ位友人名字的信封，a、b、c……表示ｎ份相应的写好的信纸。把错装的总数为记作
//D(n)。假设把ａ错装进Ｂ里了，包含着这个错误的一切错装法分两类：
//b装入Ａ里，这时每种错装的其余部分都与A、B、a、b无关，应有D(n－2)种错装法。
//ｂ装入A、B之外的一个信封，这时的装信工作实际是把（除a之外的）n－1份信纸ｂ、ｃ……装入（除B以外
//的）n－1个信封A、C……，显然这时装错的方法有D(n－1)种。
//总之在ａ装入B的错误之下，共有错装法D(n－2)＋D(n－1)种。
//a装入C，装入D……的n－2种错误之下，同样都有D(n－1)＋D(n－2)种错装法，因此D(n)＝(n－1)[D(n－1)＋D(n－
//2)]
//D(n) = (n-1) [D(n-2) + D(n-1)]
//特殊地，D(1) = 0, D(2) = 1. 


//递归公式D(n) = (n-1) [D(n-2) + D(n-1)]
using namespace std;
int main() {
  long long f[21]={0,0,1};//错排，无人获奖情况
  long long N[21]={1,1,2};//阶乘，全部情况
                          //概率=无人获奖情况/全部情况
    for(int i =3;i<=20;i++)
    {
        f[i]=(i-1)*(f[i-1]+f[i-2]);
        N[i]=i*N[i-1];
    }
    int n=0;
    while(cin>>n)
    {

        printf("%.2f%%\n",1.0*100 * f[n] / N[n]);//连续类型转换成double
    }
    return 0;
}
